/*
* Copyright 2011-2018 Branimir Karadzic. All rights reserved.
* License: https://github.com/bkaradzic/bgfx#license-bsd-2-clause
*/
#define ENTRY_CONFIG_IMPLEMENT_MAIN 1

#include <common.h>
#include <camera.h>
#include <bx/rng.h>
#include <bgfx_utils.h>
#include <imgui/imgui.h>
#include <algorithm>
#include <cstring>
#include <cstdio>
#include <exception>
#include <fstream>
#include <iostream>
#include <limits>
#include <string>
#include <vector>

struct PosColorVertex
{
  float m_x;
  float m_y;
  float m_z;
  uint32_t m_abgr;

  static void init()
  {
    ms_decl
      .begin()
      .add(bgfx::Attrib::Position, 3, bgfx::AttribType::Float)
      .add(bgfx::Attrib::Color0, 4, bgfx::AttribType::Uint8, true)
      .end();
  };

  static bgfx::VertexDecl ms_decl;
};

bgfx::VertexDecl PosColorVertex::ms_decl;

static PosColorVertex s_cubeVertices[8] =
{
  { -1.0f, 1.0f, 1.0f, 0xff000000 },
{ 1.0f, 1.0f, 1.0f, 0xff0000ff },
{ -1.0f, -1.0f, 1.0f, 0xff00ff00 },
{ 1.0f, -1.0f, 1.0f, 0xff00ffff },
{ -1.0f, 1.0f, -1.0f, 0xffff0000 },
{ 1.0f, 1.0f, -1.0f, 0xffff00ff },
{ -1.0f, -1.0f, -1.0f, 0xffffff00 },
{ 1.0f, -1.0f, -1.0f, 0xffffffff },
};

static const uint16_t s_cubeIndices[36] =
{
  0, 1, 2, // 0
  1, 3, 2,
  4, 6, 5, // 2
  5, 6, 7,
  0, 2, 4, // 4
  4, 2, 6,
  1, 5, 3, // 6
  5, 7, 3,
  0, 4, 1, // 8
  4, 5, 1,
  2, 3, 6, // 10
  6, 3, 7,
};

bool starts_with(const char* searchin, const char* searchfor) {
  int i = 0;
  while (searchfor[i] && searchin[i] && searchin[i]==searchfor[i]) {
    ++i;
  }
  return searchfor[i] == '\0';
}

template <typename T>
struct Vec2 {
  T x, y;
};

template <typename T>
struct Circle {
  Vec2<T> center;
  T radius;
};

template <typename T>
struct Vec3 {
  T x, y, z;
};

struct Particle {
  Vec3<float> pos;
  Vec3<float> vel;
};

struct BoundingBox {
  Vec3<float> min;
  Vec3<float> max;
};

template <typename T>
Vec3<T> operator+(Vec3<T> u, Vec3<T> v) {
  return Vec3<T>{u.x+v.x, u.y+v.y, u.z+v.z};
}

template <typename T>
Vec3<T> operator-(Vec3<T> u, Vec3<T> v) {
  return Vec3<T>{u.x-v.x, u.y-v.y, u.z-v.z};
}

template <typename T>
Vec3<T> operator/(Vec3<T> u, T s) {
  return Vec3<T>{u.x/s, u.y/s, u.z/s};
}

template <typename T>
Vec3<T> operator*(Vec3<T> u, T s) {
  return Vec3<T>{u.x*s, u.y*s, u.z*s};
}
struct ParticleArray {
  std::vector<std::vector<Vec3<float>>> position;
  std::vector<std::vector<Vec3<float>>> velocity;
  std::vector<std::vector<float>> concentration;
};

ParticleArray parse_gro(const char* file_name) {
  std::ifstream fs(file_name);
  if (!fs) {
    throw new std::runtime_error("Cannot open file " + std::string(file_name));
  }
  ParticleArray particles;
  std::vector<Vec3<float>> positions_per_time_step;
  std::vector<Vec3<float>> velocities_per_time_step;
  std::string line;
  int nparticles = 0;
  int i = 0;
  while (true) {
    std::getline(fs, line);
    if (!fs) {
      break;
    }
    float time;
    bool new_time_step = starts_with(line.data(), "Generated");
    if (new_time_step) {
      sscanf(line.data(), "Generated by trjconv : Dzugutov system t=%f", &time);
      std::getline(fs, line); // number of particles
      nparticles = std::stoi(line);
    }
    else { // within a time step
      if (i < nparticles) {
        float px, py, pz, vx, vy, vz;
        int temp;
        sscanf(line.data(), "%dDZATO DZ%d %f %f %f %f %f %f", &temp, &temp, &px, &py, &pz, &vx, &vy, &vz);
        ++i;
        positions_per_time_step.emplace_back(Vec3<float>{px, py, pz});
        velocities_per_time_step.emplace_back(Vec3<float>{vx, vy, vz});
      }
      else { // finished reading all particles in the current time step
        i = 0;
        if (!positions_per_time_step.empty()) {
          particles.position.push_back(positions_per_time_step);
          particles.velocity.push_back(velocities_per_time_step);
        }
        positions_per_time_step.clear();
        velocities_per_time_step.clear();
      }
    }
  }
  return particles;
}

ParticleArray parse_xyz(const char* file_name) {
  std::ifstream fs(file_name);
  if (!fs) {
    throw new std::runtime_error("Cannot open file " + std::string(file_name));
  }
  ParticleArray particles;
  std::vector<Vec3<float>> positions_per_time_step;
  std::string line;
  std::getline(fs, line);
  int nparticles = std::stoi(line);
  std::getline(fs, line);
  char temp[10];
  while (fs) {
    std::getline(fs, line);
    char c; float px, py, pz;
    sscanf(line.data(), "%s %f %f %f", &temp, &px, &py, &pz);
    positions_per_time_step.emplace_back(Vec3<float>{px, py, pz});
  }
  particles.position.push_back(positions_per_time_step);
  return particles;
}

ParticleArray parse_vtu(const char* file_name) {
  FILE *fp = fopen(file_name, "rb");
  if (!fp) {
    throw new std::runtime_error("Cannot open file " + std::string(file_name));
  }
  struct Header {
    uint32_t pad3;
    uint32_t size;
    uint32_t pad1;
    uint32_t step;
    uint32_t pad2;
    float time;
  };
  Header header;
  int magic_offset = 4072;
  fseek(fp, magic_offset, SEEK_SET);
  fread(&header, sizeof header, 1, fp);
  ParticleArray particles;
  particles.position.resize(1, std::vector<Vec3<float>>(header.size));
  particles.velocity.resize(1, std::vector<Vec3<float>>(header.size));
  particles.concentration.resize(1, std::vector<float>(header.size));

  fseek(fp, 4, SEEK_CUR);
  fread(particles.position[0].data(), 3*header.size*sizeof(float), 1, fp);
  fseek(fp, 4, SEEK_CUR);
  fread(particles.velocity[0].data(), 3*header.size*sizeof(float), 1, fp);
  fseek(fp, 4, SEEK_CUR);
  fread(particles.concentration[0].data(), header.size*sizeof(float), 1, fp);
  fclose(fp);
  return particles;
}

BoundingBox compute_bounding_box(const std::vector<std::vector<Vec3<float>>>& particles) {
  BoundingBox bbox;
  bbox.min.x = bbox.min.y = bbox.min.z = std::numeric_limits<float>::max();
  bbox.max.x = bbox.max.y = bbox.max.z = -std::numeric_limits<float>::max();
  for (const auto& particles_per_time_step : particles) {
    for (const auto& p : particles_per_time_step) {
      bbox.min.x = std::min(bbox.min.x, p.x);
      bbox.min.y = std::min(bbox.min.y, p.y);
      bbox.min.z = std::min(bbox.min.z, p.z);
      bbox.max.x = std::max(bbox.max.x, p.x);
      bbox.max.y = std::max(bbox.max.y, p.y);
      bbox.max.z = std::max(bbox.max.z, p.z);
    }
  }
  return bbox;
}

/** Rescale the particle positions, given a maximum dimension, and translate them so that the center
of the bounding box is at (0, 0, 0) */
void rescale_particles(std::vector<std::vector<Vec3<float>>>& particles, float max_dim) {
  BoundingBox bbox = compute_bounding_box(particles);
  Vec3<float> center = (bbox.min+bbox.max) / 2.0f;
  for (auto& particles_per_time_step : particles) {
    for (auto& p : particles_per_time_step) {
      p = p - center;
    }
  }
  float dx = bbox.max.x - bbox.min.x;
  float dy = bbox.max.y - bbox.min.y;
  float dz = bbox.max.z - bbox.min.z;
  float dmax = std::max(std::max(dx, dy), dz);
  float s = max_dim / dmax;
  for (auto& particles_per_time_step : particles) {
    for (auto& p : particles_per_time_step) {
      p = p * s;
    }
  }
}

ParticleArray particles_;

using Mat4 = float[16]; // column-major matrix

struct Quat {
  float w, x, y, z;
};

Quat quat_mul(Quat q0, Quat q1) {
  return Quat{ q0.w*q1.w - q0.x*q1.x - q0.y*q1.y - q0.z*q1.z,
    q0.w*q1.x + q1.w*q0.x + q0.y*q1.z - q0.z*q1.y,
    q0.w*q1.y + q1.w*q0.y - q0.x*q1.z + q0.z*q1.x,
    q0.w*q1.z + q1.w*q0.z + q0.x*q1.y - q0.y*q1.x };
}

Vec3<float> arcball_screen_to_sphere(Circle<float> circle, Vec2<float> pos) {
  auto x = (pos.x - circle.center.x) / circle.radius;
  auto y = -(pos.y - circle.center.y) / circle.radius;
  auto r = x*x + y*y;
  if (r > 1.0f) {
    auto s = 1.0f / sqrt(r);
    return Vec3<float>{s*x, s*y, 0.0f};
  }
  else {
    return Vec3<float>{x, y, sqrt(1.0f-r)};
  }
}

float vec3_dot(Vec3<float> u, Vec3<float> v) {
  return u.x*v.x + u.y*v.y + u.z*v.z;
}

Vec3<float> vec3_cross(Vec3<float> u, Vec3<float> v) {
  return Vec3<float>{u.y*v.z-u.z*v.y, u.z*v.x-u.x*v.z, u.x*v.y-u.y*v.x};
}

Quat arcball_quat(Vec3<float> start_point, Vec3<float> end_point) {
  auto axis = vec3_cross(start_point, end_point);
  auto angle = vec3_dot(start_point, end_point);
  return Quat{ angle, axis.x, axis.y, axis.z };
}

void quat_to_mat4(Quat q, Mat4 mat) {
  mat[0 ] = 1.0 - 2.0*q.y*q.y - 2.0*q.z*q.z;
  mat[1 ] = 2.0*q.x*q.y + 2.0*q.w*q.z;
  mat[2 ] = 2.0*q.x*q.z - 2.0*q.w*q.y;
  mat[3 ] = 0.0;
  mat[4 ] = 2.0*q.x*q.y - 2.0*q.w*q.z;
  mat[5 ] = 1.0 - 2.0*q.x*q.x - 2.0*q.z*q.z;
  mat[6 ] = 2.0*q.y*q.z + 2.0*q.w*q.x;
  mat[7 ] = 0.0;
  mat[8 ] = 2.0*q.x*q.z + 2.0*q.w*q.y;
  mat[9 ] = 2.0*q.y*q.z - 2.0*q.w*q.x;
  mat[10] = 1.0 - 2.0*q.x*q.x - 2.0*q.y*q.y;
  mat[11] = 0.0;
  mat[12] = 0.0;
  mat[13] = 0.0;
  mat[14] = 0.0;
  mat[15] = 1.0;
}

class ExampleInstancing : public entry::AppI
{
public:
  ExampleInstancing(const char* _name, const char* _description)
    : entry::AppI(_name, _description)
  {
    particles_ = parse_gro("D:/Datasets/particles/alfredo/t0-t192000-s1000.gro");
    //particles_ = parse_xyz("D:/Datasets/priya/785000.xyz");
    //particles_ = parse_vtu("D:/Datasets/VisContest2016/sl0.20/raw/run12/120.vtu");
    rescale_particles(particles_.position, 200);
  }

  void init(int32_t _argc, const char* const* _argv, uint32_t _width, uint32_t _height) override
  {
    Args args(_argc, _argv);

    m_width = _width;
    m_height = _height;
    m_debug = BGFX_DEBUG_TEXT;
    m_reset = BGFX_RESET_VSYNC;

    bgfx::Init init;
    init.type = args.m_type;
    init.vendorId = args.m_pciId;
    init.resolution.width = m_width;
    init.resolution.height = m_height;
    init.resolution.reset = m_reset;
    bgfx::init(init);

    // Enable debug text.
    bgfx::setDebug(m_debug);

    // Set view 0 clear state.
    bgfx::setViewClear(0
      , BGFX_CLEAR_COLOR | BGFX_CLEAR_DEPTH
      , 0x303030ff
      , 1.0f
      , 0
    );

    // Create vertex stream declaration.
    PosColorVertex::init();

    // Create static vertex buffer.
    m_vbh = bgfx::createVertexBuffer(
      bgfx::makeRef(s_cubeVertices, sizeof(s_cubeVertices))
      , PosColorVertex::ms_decl
    );

    // Create static index buffer.
    m_ibh = bgfx::createIndexBuffer(
      bgfx::makeRef(s_cubeIndices, sizeof(s_cubeIndices))
    );

    // Create program from shaders.
    m_program = loadProgram("vs_instancing", "fs_instancing");

    m_timeOffset = bx::getHPCounter();

    imguiCreate();

    //cameraCreate();

    //const float initialPos[3] = { 0.0f, 0.0f, 300.0f };
    //cameraSetPosition(initialPos);
    //cameraSetVerticalAngle(0.0f);
  }

  int shutdown() override
  {
    imguiDestroy();

    // Cleanup.
    bgfx::destroy(m_ibh);
    bgfx::destroy(m_vbh);
    bgfx::destroy(m_program);

    // Shutdown bgfx.
    bgfx::shutdown();

    return 0;
  }

  Vec2<float> mouse_now_;
  Vec2<float> mouse_last_;
  Vec2<float> right_mouse_last_;
  Vec2<float> right_mouse_now_;
  bool mouse_down_ = false;
  bool right_mouse_down_ = false;
  Quat q_{1.0, 0.0, 0.0, 0.0};
  Quat q_down_;
  float translate_ = 300.0f;
  float translate_down_;
  int timestep_ = 0;

  bool update() override
  {
    if (!entry::processEvents(m_width, m_height, m_debug, m_reset, &m_mouseState))
    {
      imguiBeginFrame(m_mouseState.m_mx
        , m_mouseState.m_my
        , (m_mouseState.m_buttons[entry::MouseButton::Left] ? IMGUI_MBUT_LEFT : 0)
        | (m_mouseState.m_buttons[entry::MouseButton::Right] ? IMGUI_MBUT_RIGHT : 0)
        | (m_mouseState.m_buttons[entry::MouseButton::Middle] ? IMGUI_MBUT_MIDDLE : 0)
        , m_mouseState.m_mz
        , uint16_t(m_width)
        , uint16_t(m_height)
      );

      showExampleDialog(this);
      ImGui::SliderInt("Time", &timestep_, 0, particles_.position.size()-1, NULL);

      imguiEndFrame();

      Circle<float> arcball_circle = { Vec2<float>{m_width/2.0f, m_height/2.0f}, std::min(m_width/2.0f, m_height/2.0f) };

      if (!ImGui::GetIO().WantCaptureMouse) {
        if (!mouse_down_) {
          mouse_last_.x = m_mouseState.m_mx;
          mouse_last_.y = m_mouseState.m_my;
          q_down_ = q_;
        }
        mouse_down_ = !!m_mouseState.m_buttons[entry::MouseButton::Left];
        if (mouse_down_) {
          mouse_now_.x = m_mouseState.m_mx;
          mouse_now_.y = m_mouseState.m_my;
          auto p0 = arcball_screen_to_sphere(arcball_circle, mouse_last_);
          auto p1 = arcball_screen_to_sphere(arcball_circle, mouse_now_);
          auto q_move_ = arcball_quat(p1, p0);
          q_ = quat_mul(q_move_, q_down_);
        }
      }

      if (!right_mouse_down_) {
        right_mouse_last_.x = m_mouseState.m_mx;
        right_mouse_last_.y = m_mouseState.m_my;
        translate_down_ = translate_;
      }
      right_mouse_down_ = !!m_mouseState.m_buttons[entry::MouseButton::Right];
      if (right_mouse_down_) {
        right_mouse_now_.x = m_mouseState.m_mx;
        right_mouse_now_.y = m_mouseState.m_my;
        float dy = right_mouse_now_.y - right_mouse_last_.y;
        float translate_more = dy * 0.5;
        translate_ = translate_down_ + translate_more;
      }
      float view[16];
      quat_to_mat4(q_, view);

      // Set view 0 default viewport.
      bgfx::setViewRect(0, 0, 0, uint16_t(m_width), uint16_t(m_height));

      // This dummy draw call is here to make sure that view 0 is cleared
      // if no other draw calls are submitted to view 0.
      bgfx::touch(0);

      float time = (float)((bx::getHPCounter() - m_timeOffset) / double(bx::getHPFrequency()));

      // Get renderer capabilities info.
      const bgfx::Caps* caps = bgfx::getCaps();

      // Check if instancing is supported.
      if (0 == (BGFX_CAPS_INSTANCING & caps->supported))
      {
        // When instancing is not supported by GPU, implement alternative
        // code path that doesn't use instancing.
        bool blink = uint32_t(time*3.0f) & 1;
        bgfx::dbgTextPrintf(0, 0, blink ? 0x4f : 0x04, " Instancing is not supported by GPU. ");
      }
      else
      {
        // Set view and projection matrix for view 0.
        const bgfx::HMD* hmd = bgfx::getHMD();
        if (NULL != hmd && 0 != (hmd->flags & BGFX_HMD_RENDERING))
        {
          float view[16];
          // Set view 0 default viewport.
          //
          // Use HMD's width/height since HMD's internal frame buffer size
          // might be much larger than window size.

          float eye[3] = {0, 0, translate_};
          //cameraGetPosition(eye);
          bx::mtxQuatTranslationHMD(view, hmd->eye[0].rotation, eye);
          bgfx::setViewTransform(0, view, hmd->eye[0].projection, BGFX_VIEW_STEREO, hmd->eye[1].projection);
          bgfx::setViewRect(0, 0, 0, hmd->width, hmd->height);
        }
        else // we go this path
        {
          float proj[16];
          bx::mtxProj(proj, 60.0f, float(m_width) / float(m_height), 0.1f, 1000.0f, bgfx::getCaps()->homogeneousDepth);
          view[14] = translate_;
          bgfx::setViewTransform(0, view, proj);

          // Set view 0 default viewport.
          bgfx::setViewRect(0, 0, 0, uint16_t(m_width), uint16_t(m_height));
        }

        // 80 bytes stride = 64 bytes for 4x4 matrix + 16 bytes for RGBA color.
        const uint16_t instanceStride = 80;
        // 11x11 cubes
        const uint32_t numInstances = particles_.position[timestep_].size();

        const bgfx::Stats* stats = bgfx::getStats();
        //bgfx::dbgTextPrintf(0, 2, 0x0f, "num instance = %d", bgfx::getAvailInstanceDataBuffer(numInstances, instanceStride));
        bgfx::dbgTextPrintf(0, 2, 0x0f, "num instance real = %d %d", timestep_, numInstances);
        if (numInstances == bgfx::getAvailInstanceDataBuffer(numInstances, instanceStride))
        {
          bgfx::InstanceDataBuffer idb;
          bgfx::allocInstanceDataBuffer(&idb, numInstances, instanceStride);

          uint8_t* data = idb.data;

          for (uint32_t yy = 0; yy < numInstances; ++yy)
          {
            float* mtx = (float*)data;
            bx::mtxRotateXY(mtx, 0, 0);
            mtx[12] = particles_.position[timestep_][yy].x;
            mtx[13] = particles_.position[timestep_][yy].y;
            mtx[14] = particles_.position[timestep_][yy].z;

            float* color = (float*)&data[64];
            color[0] = bx::sin(11.0f)*0.5f + 0.5f;
            color[1] = bx::cos(11.0f)*0.5f + 0.5f;
            color[2] = bx::sin(3.0f)*0.5f + 0.5f;
            color[3] = 1.0f;

            data += instanceStride;
          }

          // Set vertex and index buffer.
          bgfx::setVertexBuffer(0, m_vbh);
          bgfx::setIndexBuffer(m_ibh);

          // Set instance data buffer.
          bgfx::setInstanceDataBuffer(&idb);

          // Set render states.
          bgfx::setState(BGFX_STATE_DEFAULT);

          // Submit primitive for rendering to view 0.
          bgfx::submit(0, m_program);
        }
      }

      // Advance to next frame. Rendering thread will be kicked to
      // process submitted rendering primitives.
      bgfx::frame();

      return true;
    }

    return false;
  }

  entry::MouseState m_mouseState;

  uint32_t m_width;
  uint32_t m_height;
  uint32_t m_debug;
  uint32_t m_reset;
  bgfx::VertexBufferHandle m_vbh;
  bgfx::IndexBufferHandle  m_ibh;
  bgfx::ProgramHandle m_program;

  int64_t m_timeOffset;
};

ENTRY_IMPLEMENT_MAIN(ExampleInstancing, "05-instancing", "Geometry instancing.");
//int main(int argc, char** argv) {
//  ExampleInstancing app("05-instancing", "Geometry instancing");
//  return entry::runApp(&app, argc, argv);
//}
